[
  {
    "name": "Dense",
    "cat": "core",
    "desc": "Dense implements the operation: output = activation(dot(input, kernel) + bias) where activation is the element-wise activation function passed as the activation argument, kernel is a weights matrix created by the layer, and bias is a bias vector created by the layer (only applicable if use_bias is True).",
    "params": [
      {
        "name": "units",
        "optional": false,
        "type": "int",
        "desc": "Positive integer, dimensionality of the output space."
      },
      {
        "name": "activation",
        "optional": true,
        "default": "relu",
        "type": "opt",
        "optname": "activations",
        "desc": "Activation function to use. If you dont specify anything, no activation is applied (ie. linear activation: a(x) = x)."
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "Dropout",
    "cat": "core",
    "desc": "Dropout consists in randomly setting a fraction rate of input units to 0 at each update during training time, which helps prevent overfitting.",
    "params": [
      {
        "name": "rate",
        "optional": false,
        "type": "float",
        "desc": "float between 0 and 1. Fraction of the input units to drop."
      }
    ]
  },
  {
    "name": "Flatten",
    "cat": "core",
    "desc": "Flattens the input. Does not affect the batch size."
  },
  {
    "name": "Reshape",
    "cat": "core",
    "desc": "Reshapes an output to a certain shape.",
    "params": [
      {
        "name": "target_shape",
        "optional": false,
        "type": "tuple",
        "desc": "Tuple of integers. Does not include the batch axis."
      }
    ]
  },
  {
    "name": "Conv1D",
    "cat": "convolutional",
    "desc": "This layer creates a convolution kernel that is convolved with the layer input over a single spatial (or temporal) dimension to produce a tensor of outputs. If use_bias is True, a bias vector is created and added to the outputs. Finally, if activation is not None, it is applied to the outputs as well. When using this layer as the first layer in a model, provide an input_shape argument (tuple of integers or None, e.g. (10, 128) for sequences of 10 vectors of 128-dimensional vectors, or (None, 128) for variable-length sequences of 128-dimensional vectors.",
    "params": [
      {
        "name": "filters",
        "optional": false,
        "type": "int",
        "desc": "Integer, the dimensionality of the output space (i.e. the number output of filters in the convolution)."
      },
      {
        "name": "kernel_size",
        "optional": false,
        "type": "int",
        "desc": "An integer or tuple/list of a single integer, specifying the length of the 1D convolution window."
      },
      {
        "name": "strides",
        "optional": true,
        "default": 1,
        "type": "int",
        "desc": " An integer or tuple/list of a single integer, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1."
      },
      {
        "name": "padding",
        "optional": true,
        "default": "valid",
        "type": "string",
        "desc": "One of \"valid\", \"causal\" or \"same\" (case-insensitive).  \"valid\" means \"no padding\". \"same\" results in padding the input such that the output has the same length as the original input.  \"causal\" results in causal (dilated) convolutions, e.g. output[t] does not depend on input[t+1:]. Useful when modeling temporal data where the model should not violate the temporal order."
      },
      {
        "name": "dilation_rate",
        "optional": true,
        "default": 1,
        "type": "int",
        "desc": "an integer or tuple/list of a single integer, specifying the dilation rate to use for dilated convolution. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any strides value != 1."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "relu",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "Conv2D",
    "cat": "convolutional",
    "desc": "This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs. If  use_bias is True, a bias vector is created and added to the outputs. Finally, if activation is not None, it is applied to the outputs as well. When using this layer as the first layer in a model, provide the keyword argument input_shape (tuple of integers, does not include the sample axis), e.g. input_shape=(128, 128, 3) for 128x128 RGB pictures in  data_format=\"channels_last\".",
    "params": [
      {
        "name": "filters",
        "optional": false,
        "type": "int",
        "desc": "Integer, the dimensionality of the output space (i.e. the number output of filters in the convolution)."
      },
      {
        "name": "kernel_size",
        "optional": false,
        "type": "int",
        "desc": "An integer or tuple/list of 2 integers, specifying the length of the 2D convolution window."
      },
      {
        "name": "strides",
        "optional": true,
        "default": [ 1, 1 ],
        "type": "tuple",
        "desc": " An integer or tuple/list of 2 integer2, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1."
      },
      {
        "name": "padding",
        "optional": true,
        "default": "valid",
        "type": "string",
        "desc": "One of \"valid\", \"causal\" or \"same\" (case-insensitive).  \"valid\" means \"no padding\". \"same\" results in padding the input such that the output has the same length as the original input.  \"causal\" results in causal (dilated) convolutions, e.g. output[t] does not depend on input[t+1:]. Useful when modeling temporal data where the model should not violate the temporal order."
      },
      {
        "name": "dilation_rate",
        "optional": true,
        "default": [ 1, 1 ],
        "type": "tuple",
        "desc": "an integer or tuple/list of a single integer, specifying the dilation rate to use for dilated convolution. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any strides value != 1."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "relu",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "Conv3D",
    "cat": "convolutional",
    "desc": "This layer creates a convolution kernel that is convolved with the layer input to produce a tensor of outputs. If  use_bias is True, a bias vector is created and added to the outputs. Finally, if activation is not None, it is applied to the outputs as well. When using this layer as the first layer in a model, provide the keyword argument input_shape (tuple of integers, does not include the sample axis), e.g. input_shape=(128, 128, 128, 1) for 128x128x128 volumes with a single channel, in data_format=\"channels_last\".",
    "params": [
      {
        "name": "filters",
        "optional": false,
        "type": "int",
        "desc": "Integer, the dimensionality of the output space (i.e. the number output of filters in the convolution)."
      },
      {
        "name": "kernel_size",
        "optional": false,
        "type": "int",
        "desc": "An integer or tuple/list of 3 integers, specifying the length of the 3D convolution window."
      },
      {
        "name": "strides",
        "optional": true,
        "default": [ 1, 1, 1 ],
        "type": "tuple",
        "desc": " An integer or tuple/list of 3 integers, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1."
      },
      {
        "name": "padding",
        "optional": true,
        "default": "valid",
        "type": "string",
        "desc": "One of \"valid\", \"causal\" or \"same\" (case-insensitive).  \"valid\" means \"no padding\". \"same\" results in padding the input such that the output has the same length as the original input.  \"causal\" results in causal (dilated) convolutions, e.g. output[t] does not depend on input[t+1:]. Useful when modeling temporal data where the model should not violate the temporal order."
      },
      {
        "name": "dilation_rate",
        "optional": true,
        "default": [ 1, 1, 1 ],
        "type": "tuple",
        "desc": "an integer or tuple/list of a single integer, specifying the dilation rate to use for dilated convolution. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any strides value != 1."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "relu",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "SeparableConv2D",
    "func": "keras.layers.convolutional.SeparableConv2D",
    "cat": "convolutional",
    "desc": "Separable convolutions consist in first performing a depthwise spatial convolution (which acts on each input channel separately) followed by a pointwise convolution which mixes together the resulting output channels. The  depth_multiplier argument controls how many output channels are generated per input channel in the depthwise step. Intuitively, separable convolutions can be understood as a way to factorize a convolution kernel into two smaller kernels, or as an extreme version of an Inception block.",
    "params": [
      {
        "name": "filters",
        "optional": false,
        "type": "int",
        "desc": "Integer, the dimensionality of the output space (i.e. the number output of filters in the convolution)."
      },
      {
        "name": "kernel_size",
        "optional": false,
        "type": "int",
        "desc": "An integer or tuple/list of 2 integers, specifying the length of the 2D convolution window."
      },
      {
        "name": "strides",
        "optional": true,
        "default": [ 1, 1 ],
        "type": "tuple",
        "desc": " An integer or tuple/list of 2 integer2, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1."
      },
      {
        "name": "padding",
        "optional": true,
        "default": "valid",
        "type": "string",
        "desc": "one of \"valid\" or \"same\" (case-insensitive)."
      },
      {
        "name": "depth_multiplier",
        "optional": true,
        "type": "int",
        "default": 1,
        "desc": " The number of depthwise convolution output channels for each input channel. The total number of depthwise convolution output channels will be equal to filterss_in * depth_multiplier."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "relu",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "depthwise_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "pointwise_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "depthwise_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "pointwise_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "depthwise_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "pointwise_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "Conv2DTranspose",
    "func": "keras.layers.convolutional.Conv2DTranspose",
    "cat": "convolutional",
    "desc": "The need for transposed convolutions generally arises from the desire to use a transformation going in the opposite direction of a normal convolution, i.e., from something that has the shape of the output of some convolution to something that has the shape of its input while maintaining a connectivity pattern that is compatible with said convolution. When using this layer as the first layer in a model, provide the keyword argument input_shape (tuple of integers, does not include the sample axis), e.g. input_shape=(128, 128, 3) for 128x128 RGB pictures in  data_format=\"channels_last\".",
    "params": [
      {
        "name": "filters",
        "optional": false,
        "type": "int",
        "desc": "Integer, the dimensionality of the output space (i.e. the number output of filters in the convolution)."
      },
      {
        "name": "kernel_size",
        "optional": false,
        "type": "int",
        "desc": "An integer or tuple/list of 2 integers, specifying the length of the 2D convolution window."
      },
      {
        "name": "strides",
        "optional": true,
        "default": [ 1, 1 ],
        "type": "tuple",
        "desc": " An integer or tuple/list of 2 integer2, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1."
      },
      {
        "name": "padding",
        "optional": true,
        "default": "valid",
        "type": "string",
        "desc": "one of \"valid\" or \"same\" (case-insensitive)."
      },
      {
        "name": "dilation_rate",
        "optional": true,
        "default": [ 1, 1 ],
        "type": "tuple",
        "desc": "an integer or tuple/list of a single integer, specifying the dilation rate to use for dilated convolution. Currently, specifying any dilation_rate value != 1 is incompatible with specifying any strides value != 1."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "relu",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "Cropping1D",
    "cat": "convolutional",
    "desc": "Cropping layer for 1D input (e.g. temporal sequence). It crops along the time dimension (axis 1).",
    "params": [
      {
        "name": "cropping",
        "optional": true,
        "type": "tuple",
        "default": [ 1, 1 ],
        "desc": "Tuple of int (length 2) How many units should be trimmed off at the beginning and end of the cropping dimension (axis 1). If a single int is provided, the same value will be used for both."
      }
    ]
  },
  {
    "name": "Cropping2D",
    "cat": "convolutional",
    "desc": "Cropping layer for 2D input (e.g. picture). It crops along spatial dimensions, i.e. width and height.",
    "params": [
      {
        "name": "cropping",
        "optional": true,
        "type": "tuple",
        "default": [
          [ 0, 0 ],
          [ 0, 0 ]
        ],
        "desc": "Tuple of 2 tuples of 2 ints ((top_crop, bottom_crop), (left_crop, right_crop))"
      }
    ]
  },
  {
    "name": "Cropping3D",
    "cat": "convolutional",
    "desc": "Cropping layer for 3D data (e.g. spatial or spatio-temporal).",
    "params": [
      {
        "name": "cropping",
        "optional": true,
        "type": "tuple",
        "default": [
          [ 1, 1 ],
          [ 1, 1 ],
          [ 1, 1 ]
        ],
        "desc": "Tuple of 2 tuples of 2 ints ((left_dim1_crop, right_dim1_crop), (left_dim2_crop, right_dim2_crop), (left_dim3_crop, right_dim3_crop))"
      }
    ]
  },
  {
    "name": "UpSampling1D",
    "cat": "convolutional",
    "desc": "Repeats each temporal step size times along the time axis.",
    "params": [
      {
        "name": "size",
        "optional": true,
        "type": "int",
        "default": 2,
        "desc": "integer. Upsampling factor."
      }
    ]
  },
  {
    "name": "UpSampling2D",
    "cat": "convolutional",
    "desc": "Repeats the rows and columns of the data by size[0] and size[1] respectively.",
    "params": [
      {
        "name": "size",
        "optional": true,
        "type": "tuple",
        "default": [ 2, 2 ],
        "desc": "Tuple of 2 integers. The upsampling factors for rows and columns."
      }
    ]
  },
  {
    "name": "UpSampling3D",
    "cat": "convolutional",
    "desc": "Repeats the 1st, 2nd and 3rd dimensions of the data by size[0], size[1] and size[2] respectively.",
    "params": [
      {
        "name": "size",
        "optional": true,
        "type": "tuple",
        "default": [ 2, 2, 2 ],
        "desc": "Tuple of 3 integers. The upsampling factors for dim1, dim2 and dim3."
      }
    ]
  },
  {
    "name": "ZeroPadding1D",
    "cat": "convolutional",
    "desc": "Repeats each temporal step size times along the time axis.",
    "params": [
      {
        "name": "padding",
        "optional": true,
        "type": "int",
        "default": 1,
        "desc": "integer. Padding length"
      }
    ]
  },
  {
    "name": "ZeroPadding2D",
    "cat": "convolutional",
    "desc": "Zero-padding layer for 2D input (e.g. picture). This layer can add rows and columns of zeros at the top, bottom, left and right side of an image tensor.",
    "params": [
      {
        "name": "padding",
        "optional": true,
        "type": "tuple",
        "default": [ 1, 1 ],
        "desc": "Tuple of 2 ints: interpreted as two different symmetric padding values for height and width: (symmetric_height_pad, symmetric_width_pad)."
      }
    ]
  },
  {
    "name": "ZeroPadding3D",
    "cat": "convolutional",
    "desc": "Zero-padding layer for 3D data (spatial or spatio-temporal).",
    "params": [
      {
        "name": "padding",
        "optional": true,
        "type": "tuple",
        "default": [ 1, 1, 1 ],
        "desc": "Tuple of 3 ints: interpreted as two different symmetric padding values for height and width: (symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)."
      }
    ]
  },
  {
    "name": "MaxPooling1D",
    "cat": "pooling",
    "desc": "Max pooling operation for temporal data.",
    "params": [
      {
        "name": "pool_size",
        "optional": true,
        "type": "int",
        "default": 2,
        "desc": "Integer, size of the max pooling windows."
      },
      {
        "name": "strides",
        "optional": true,
        "type": "int",
        "desc": "Integer, or None. Factor by which to downscale. E.g. 2 will halve the input. If None, it will default to pool_size."
      },
      {
        "name": "padding",
        "optional": true,
        "type": "string",
        "default": "valid",
        "desc": "One of \"valid\" or \"same\" (case-insensitive)."
      }
    ]
  },
  {
    "name": "MaxPooling2D",
    "cat": "pooling",
    "desc": "Max pooling operation for spatial data.",
    "params": [
      {
        "name": "pool_size",
        "optional": true,
        "type": "tuple",
        "default": [ 2, 2 ],
        "desc": "Tuple of 2 integers, factors by which to downscale (vertical, horizontal). (2, 2) will halve the input in both spatial dimension."
      },
      {
        "name": "strides",
        "optional": true,
        "type": "tuple",
        "desc": "Tuple of 2 integers, or None. Strides values. If None, it will default to pool_size."
      },
      {
        "name": "padding",
        "optional": true,
        "type": "string",
        "default": "valid",
        "desc": "One of \"valid\" or \"same\" (case-insensitive)."
      }
    ]
  },
  {
    "name": "MaxPooling3D",
    "cat": "pooling",
    "desc": "Max pooling operation for 3D data (spatial or spatio-temporal).",
    "params": [
      {
        "name": "pool_size",
        "optional": true,
        "type": "tuple",
        "default": [ 2, 2, 2 ],
        "desc": "Tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). (2, 2, 2) will halve the size of the 3D input in each dimension."
      },
      {
        "name": "strides",
        "optional": true,
        "type": "tuple",
        "desc": "Tuple of 3 integers, or None. Strides values."
      },
      {
        "name": "padding",
        "optional": true,
        "type": "string",
        "default": "valid",
        "desc": "One of \"valid\" or \"same\" (case-insensitive)."
      }
    ]
  },
  {
    "name": "AveragePooling1D",
    "cat": "pooling",
    "desc": "Average pooling operation for temporal data.",
    "params": [
      {
        "name": "pool_size",
        "optional": true,
        "type": "int",
        "default": 2,
        "desc": "Integer, size of the max pooling windows."
      },
      {
        "name": "strides",
        "optional": true,
        "type": "int",
        "desc": "Integer, or None. Factor by which to downscale. E.g. 2 will halve the input. If None, it will default to pool_size."
      },
      {
        "name": "padding",
        "optional": true,
        "type": "string",
        "default": "valid",
        "desc": "One of \"valid\" or \"same\" (case-insensitive)."
      }
    ]
  },
  {
    "name": "AveragePooling2D",
    "cat": "pooling",
    "desc": "Average pooling operation for spatial data.",
    "params": [
      {
        "name": "pool_size",
        "optional": true,
        "type": "tuple",
        "default": [ 2, 2 ],
        "desc": "Tuple of 2 integers, factors by which to downscale (vertical, horizontal). (2, 2) will halve the input in both spatial dimension."
      },
      {
        "name": "strides",
        "optional": true,
        "type": "tuple",
        "desc": "Tuple of 2 integers, or None. Strides values. If None, it will default to pool_size."
      },
      {
        "name": "padding",
        "optional": true,
        "type": "string",
        "default": "valid",
        "desc": "One of \"valid\" or \"same\" (case-insensitive)."
      }
    ]
  },
  {
    "name": "AveragePooling3D",
    "cat": "pooling",
    "desc": "Average pooling operation for 3D data (spatial or spatio-temporal).",
    "params": [
      {
        "name": "pool_size",
        "optional": true,
        "type": "tuple",
        "default": [ 2, 2, 2 ],
        "desc": "Tuple of 3 integers, factors by which to downscale (dim1, dim2, dim3). (2, 2, 2) will halve the size of the 3D input in each dimension."
      },
      {
        "name": "strides",
        "optional": true,
        "type": "tuple",
        "desc": "Tuple of 3 integers, or None. Strides values."
      },
      {
        "name": "padding",
        "optional": true,
        "type": "string",
        "default": "valid",
        "desc": "One of \"valid\" or \"same\" (case-insensitive)."
      }
    ]
  },
  {
    "name": "GlobalMaxPooling1D",
    "cat": "pooling",
    "desc": "Global max pooling operation for temporal data."
  },
  {
    "name": "GlobalAveragePooling1D",
    "cat": "pooling",
    "desc": "Global average pooling operation for temporal data."
  },
  {
    "name": "GlobalMaxPooling2D",
    "cat": "pooling",
    "desc": "Global max pooling operation for spatial data."
  },
  {
    "name": "GlobalAveragePooling2D",
    "cat": "pooling",
    "desc": "Global average pooling operation for spatial data."
  },
  {
    "name": "LocallyConnected1D",
    "cat": "local",
    "desc": "The LocallyConnected1D layer works similarly to the Conv1D layer, except that weights are unshared, that is, a different set of filters is applied at each different patch of the input.",
    "params": [
      {
        "name": "filters",
        "optional": false,
        "type": "int",
        "desc": "Integer, the dimensionality of the output space (i.e. the number output of filters in the convolution)."
      },
      {
        "name": "kernel_size",
        "optional": false,
        "type": "int",
        "desc": "An integer or tuple/list of a single integer, specifying the length of the 1D convolution window."
      },
      {
        "name": "strides",
        "optional": true,
        "default": 1,
        "type": "int",
        "desc": " An integer or tuple/list of a single integer, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1."
      },
      {
        "name": "padding",
        "optional": true,
        "default": "valid",
        "type": "string",
        "desc": " Currently only supports \"valid\" (case-insensitive).  \"same\" may be supported in the future."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "relu",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "LocallyConnected2D",
    "cat": "local",
    "desc": "The LocallyConnected2D layer works similarly to the Conv2D layer, except that weights are unshared, that is, a different set of filters is applied at each different patch of the input.",
    "params": [
      {
        "name": "filters",
        "optional": false,
        "type": "int",
        "desc": "Integer, the dimensionality of the output space (i.e. the number output of filters in the convolution)."
      },
      {
        "name": "kernel_size",
        "optional": false,
        "type": "tuple",
        "desc": "An integer or tuple/list of a single integer, specifying the length of the 1D convolution window."
      },
      {
        "name": "strides",
        "optional": true,
        "default": 1,
        "type": "int",
        "desc": " An integer or tuple/list of a single integer, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any dilation_rate value != 1."
      },
      {
        "name": "padding",
        "optional": true,
        "default": "valid",
        "type": "string",
        "desc": " Currently only supports \"valid\" (case-insensitive).  \"same\" may be supported in the future."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "relu",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix."
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      }
    ]
  },
  {
    "name": "LSTM",
    "cat": "recurrent",
    "desc": "Long-Short Term Memory unit - Hochreiter 1997.",
    "params": [
      {
        "name": "units",
        "optional": false,
        "type": "int",
        "desc": "Positive integer, dimensionality of the output space."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "tanh",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "recurrent_activation",
        "optional": true,
        "type": "opt",
        "default": "hard_sigmoid",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix, used for the linear transformation of the inputs."
      },
      {
        "name": "recurrent_initializer",
        "optional": true,
        "default": "orthogonal",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the recurrent_kernel weights matrix, used for the linear transformation of the recurrent state. "
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
       {
        "name": "unit_forget_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean. If True, add 1 to the bias of the forget gate at initialization. Setting it to true will also force  bias_initializer=\"zeros\". This is recommended in Jozefowicz et al."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "recurrent_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the recurrent_kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      },
      {
        "name": "dropout",
        "optional": true,
        "type": "float",
        "default": 0.0,
        "desc": "Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs."
      },
      {
        "name": "recurrent_dropout",
        "optional": true,
        "type": "float",
        "default": 0.0,
        "desc": "Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state."
      }
    ]
  },
  {
    "name": "GRU",
    "cat": "recurrent",
    "desc": "Gated Recurrent Unit - Cho et al. 2014.",
    "params": [
      {
        "name": "units",
        "optional": false,
        "type": "int",
        "desc": "Positive integer, dimensionality of the output space."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "tanh",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "recurrent_activation",
        "optional": true,
        "type": "opt",
        "default": "hard_sigmoid",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix, used for the linear transformation of the inputs."
      },
      {
        "name": "recurrent_initializer",
        "optional": true,
        "default": "orthogonal",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the recurrent_kernel weights matrix, used for the linear transformation of the recurrent state. "
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "recurrent_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the recurrent_kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      },
      {
        "name": "dropout",
        "optional": true,
        "type": "float",
        "default": 0.0,
        "desc": "Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs."
      },
      {
        "name": "recurrent_dropout",
        "optional": true,
        "type": "float",
        "default": 0.0,
        "desc": "Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state."
      }
    ]
  },
  {
    "name": "SimpleRNN",
    "cat": "recurrent",
    "desc": "Fully-connected RNN where the output is to be fed back to input.",
    "params": [
      {
        "name": "units",
        "optional": false,
        "type": "int",
        "desc": "Positive integer, dimensionality of the output space."
      },
      {
        "name": "activation",
        "optional": true,
        "type": "opt",
        "default": "tanh",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "recurrent_activation",
        "optional": true,
        "type": "opt",
        "default": "hard_sigmoid",
        "optname": "activations",
        "desc": "Activation function to use"
      },
      {
        "name": "use_bias",
        "optional": true,
        "default": true,
        "type": "bool",
        "desc": "Boolean, whether the layer uses a bias vector."
      },
      {
        "name": "kernel_initializer",
        "optional": true,
        "default": "glorot_uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the kernel weights matrix, used for the linear transformation of the inputs."
      },
      {
        "name": "recurrent_initializer",
        "optional": true,
        "default": "orthogonal",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the recurrent_kernel weights matrix, used for the linear transformation of the recurrent state. "
      },
      {
        "name": "bias_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the bias vector."
      },
      {
        "name": "kernel_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the kernel weights matrix"
      },
      {
        "name": "recurrent_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the recurrent_kernel weights matrix"
      },
      {
        "name": "bias_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the bias vector ."
      },
      {
        "name": "activity_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the output of the layer (its \"activation\")"
      },
      {
        "name": "kernel_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the kernel weights matrix"
      },
      {
        "name": "bias_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the bias vector"
      },
      {
        "name": "dropout",
        "optional": true,
        "type": "float",
        "default": 0.0,
        "desc": "Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs."
      },
      {
        "name": "recurrent_dropout",
        "optional": true,
        "type": "float",
        "default": 0.0,
        "desc": "Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state."
      }
    ]
  },
  {
    "name": "Embedding",
    "cat": "embeddings",
    "desc": "Turns positive integers (indexes) into dense vectors of fixed size. eg. [[4], [20]] -> [[0.25, 0.1], [0.6, -0.2]]. This layer can only be used as the first layer in a model.",
    "params": [
      {
        "name": "input_dim",
        "optional": false,
        "type": "int",
        "desc": "int > 0. Size of the vocabulary, i.e. maximum integer index + 1."
      },
      {
        "name": "output_dim",
        "optional": false,
        "type": "int",
        "desc": "int > 0. Dimension of the dense embedding."
      },
      {
        "name": "embeddings_initializer",
        "optional": true,
        "default": "uniform",
        "type": "opt",
        "optname": "initializers",
        "desc": " Initializer for the embeddings matrix"
      },
      {
        "name": "embeddings_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Regularizer function applied to the embeddings matrix"
      },
      {
        "name": "embeddings_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Constraint function applied to the embeddings matrix"
      },
      {
        "name": "mask_zero",
        "optional": true,
        "type": "bool",
        "default": false,
        "desc": "Whether or not the input value 0 is a special \"padding\" value that should be masked out. This is useful when using recurrent layers which may take variable length input. If this is True then all subsequent layers in the model need to support masking or an exception will be raised. If mask_zero is set to True, as a consequence, index 0 cannot be used in the vocabulary (input_dim should equal size of vocabulary + 1)."
      },
      {
        "name": "input_length",
        "optional": true,
        "type": "int",
        "desc": " Length of input sequences, when it is constant. This argument is required if you are going to connect  Flatten then Dense layers upstream (without it, the shape of the dense outputs cannot be computed)."
      }
    ]
  },
  {
    "name": "BatchNormalization",
    "cat": "normalization",
    "desc": "Normalize the activations of the previous layer at each batch, i.e. applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.",
    "params": [
      {
        "name": "axis",
        "optional": true,
        "type": "int",
        "default": -1,
        "desc": "Integer, the axis that should be normalized (typically the features axis). For instance, after a Conv2D layer with data_format=\"channels_first\", set axis=1 in BatchNormalization."
      },
      {
        "name": "momentum",
        "optional": false,
        "type": "float",
        "default": 0.99,
        "desc": "Momentum for the moving average."
      },
      {
        "name": "epsilon",
        "optional": false,
        "type": "float",
        "default": 0.001,
        "desc": "Small float added to variance to avoid dividing by zero."
      },
      {
        "name": "center",
        "optional": false,
        "type": "bool",
        "default": true,
        "desc": "If True, add offset of beta to normalized tensor. If False, beta is ignored."
      },
      {
        "name": "scale",
        "optional": false,
        "type": "bool",
        "default": true,
        "desc": "If True, multiply by gamma. If False, gamma is not used. When the next layer is linear (also e.g. nn.relu), this can be disabled since the scaling will be done by the next layer."
      },
      {
        "name": "beta_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the beta weight."
      },
      {
        "name": "gamma_initializer",
        "optional": true,
        "default": "ones",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the gamma weight."
      },
      {
        "name": "moving_mean_initializer",
        "optional": true,
        "default": "zeros",
        "type": "opt",
        "optname": "initializers",
        "desc": " Initializer for the moving mean."
      },
      {
        "name": "moving_variance_initializer",
        "optional": true,
        "default": "ones",
        "type": "opt",
        "optname": "initializers",
        "desc": "Initializer for the moving variance."
      },
      {
        "name": "beta_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Optional regularizer for the beta weight."
      },
      {
        "name": "gamma_regularizer",
        "optional": true,
        "type": "opt",
        "optname": "regularizers",
        "desc": "Optional regularizer for the gamma weight."
      },
      {
        "name": "beta_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Optional constraint for the beta weight."
      },
      {
        "name": "gamma_constraint",
        "optional": true,
        "type": "opt",
        "optname": "constraints",
        "desc": "Optional constraint for the gamma weight"
      }
    ]
  },
  {
    "name": "GaussianNoise",
    "cat": "noise",
    "desc": "Apply additive zero-centered Gaussian noise. This is useful to mitigate overfitting (you could see it as a form of random data augmentation). Gaussian Noise (GS) is a natural choice as corruption process for real valued inputs. As it is a regularization layer, it is only active at training time.",
    "params": [
      {
        "name": "stddev",
        "optional": false,
        "type": "float",
        "desc": "float, standard deviation of the noise distribution."
      }
    ]
  },
  {
    "name": "GaussianDropout",
    "cat": "noise",
    "desc": "Apply multiplicative 1-centered Gaussian noise. As it is a regularization layer, it is only active at training time.",
    "params": [
      {
        "name": "rate",
        "optional": false,
        "type": "float",
        "desc": "float, drop probability (as with Dropout). The multiplicative noise will have standard deviation  sqrt(rate / (1 - rate))."
      }
    ]
  },
  {
    "name": "AlphaDropout",
    "cat": "noise",
    "desc": "Alpha Dropout is a Dropout that keeps mean and variance of inputs to their original values, in order to ensure the self-normalizing property even after this dropout. Alpha Dropout fits well to Scaled Exponential Linear Units by randomly setting activations to the negative saturation value.",
    "params": [
      {
        "name": "rate",
        "optional": false,
        "type": "float",
        "desc": "float, drop probability (as with Dropout). The multiplicative noise will have standard deviation  sqrt(rate / (1 - rate))."
      }
    ]
  }
]